{"ast":null,"code":"import _groupBy from \"lodash/groupBy\";\nimport { WalkTreeStrategy, flattenTree } from '../utils/treeUtils';\nvar hasSymbol = typeof Symbol === 'function';\nexport var KEY_GROUP = hasSymbol ? Symbol('_$grouped') : '_$grouped';\nexport var KEY_GROUP_TITLE = 'groupTitle';\n/**\n * Chunk data into groups\n * @returns [group, child, child, group, child, child]\n */\n\nexport function getDataGroupBy(data, key, sort) {\n  var groupMap = _groupBy(data, key);\n  var isSort = typeof sort === 'function';\n  var groups = Object.entries(groupMap).map(function (_ref) {\n    var _ref2;\n    var groupTitle = _ref[0],\n      children = _ref[1];\n    return _ref2 = {\n      children: isSort ? children.sort(sort(false)) : children\n    }, _ref2[KEY_GROUP_TITLE] = groupTitle, _ref2[KEY_GROUP] = true, _ref2;\n  });\n  if (isSort) {\n    groups.sort(sort(true));\n  } // Use DFS traverse\n  // Because I want the result to be [group, child, child, group, child, child]\n  // rather than [group, group, child, child, child, child]\n\n  return flattenTree(groups, function (group) {\n    return group.children;\n  }, WalkTreeStrategy.DFS);\n}\n/**\n * Chunk options into groups\n * @returns [\n *   group {\n *     key\n *     options\n *   }\n *   group {\n *     key\n *     options\n *   }\n * ]\n */\n\nexport function groupOptions(options, groupKey, compareOptions, compareGroups) {\n  var groupMap = _groupBy(options, groupKey);\n  var groups = Object.entries(groupMap).map(function (_ref3) {\n    var key = _ref3[0],\n      options = _ref3[1];\n    return {\n      key: key,\n      options: typeof compareOptions === 'function' ? options.sort(compareOptions) : options\n    };\n  });\n  return typeof compareGroups === 'function' ? groups.sort(compareGroups) : groups;\n}","map":{"version":3,"names":["_groupBy","WalkTreeStrategy","flattenTree","hasSymbol","Symbol","KEY_GROUP","KEY_GROUP_TITLE","getDataGroupBy","data","key","sort","groupMap","isSort","groups","Object","entries","map","_ref","_ref2","groupTitle","children","group","DFS","groupOptions","options","groupKey","compareOptions","compareGroups","_ref3"],"sources":["/home/asmane/vtc/node_modules/rsuite/esm/utils/getDataGroupBy.js"],"sourcesContent":["import _groupBy from \"lodash/groupBy\";\nimport { WalkTreeStrategy, flattenTree } from '../utils/treeUtils';\nvar hasSymbol = typeof Symbol === 'function';\nexport var KEY_GROUP = hasSymbol ? Symbol('_$grouped') : '_$grouped';\nexport var KEY_GROUP_TITLE = 'groupTitle';\n/**\n * Chunk data into groups\n * @returns [group, child, child, group, child, child]\n */\n\nexport function getDataGroupBy(data, key, sort) {\n  var groupMap = _groupBy(data, key);\n\n  var isSort = typeof sort === 'function';\n  var groups = Object.entries(groupMap).map(function (_ref) {\n    var _ref2;\n\n    var groupTitle = _ref[0],\n        children = _ref[1];\n    return _ref2 = {\n      children: isSort ? children.sort(sort(false)) : children\n    }, _ref2[KEY_GROUP_TITLE] = groupTitle, _ref2[KEY_GROUP] = true, _ref2;\n  });\n\n  if (isSort) {\n    groups.sort(sort(true));\n  } // Use DFS traverse\n  // Because I want the result to be [group, child, child, group, child, child]\n  // rather than [group, group, child, child, child, child]\n\n\n  return flattenTree(groups, function (group) {\n    return group.children;\n  }, WalkTreeStrategy.DFS);\n}\n/**\n * Chunk options into groups\n * @returns [\n *   group {\n *     key\n *     options\n *   }\n *   group {\n *     key\n *     options\n *   }\n * ]\n */\n\nexport function groupOptions(options, groupKey, compareOptions, compareGroups) {\n  var groupMap = _groupBy(options, groupKey);\n\n  var groups = Object.entries(groupMap).map(function (_ref3) {\n    var key = _ref3[0],\n        options = _ref3[1];\n    return {\n      key: key,\n      options: typeof compareOptions === 'function' ? options.sort(compareOptions) : options\n    };\n  });\n  return typeof compareGroups === 'function' ? groups.sort(compareGroups) : groups;\n}"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,gBAAgB;AACrC,SAASC,gBAAgB,EAAEC,WAAW,QAAQ,oBAAoB;AAClE,IAAIC,SAAS,GAAG,OAAOC,MAAM,KAAK,UAAU;AAC5C,OAAO,IAAIC,SAAS,GAAGF,SAAS,GAAGC,MAAM,CAAC,WAAW,CAAC,GAAG,WAAW;AACpE,OAAO,IAAIE,eAAe,GAAG,YAAY;AACzC;AACA;AACA;AACA;;AAEA,OAAO,SAASC,cAAcA,CAACC,IAAI,EAAEC,GAAG,EAAEC,IAAI,EAAE;EAC9C,IAAIC,QAAQ,GAAGX,QAAQ,CAACQ,IAAI,EAAEC,GAAG,CAAC;EAElC,IAAIG,MAAM,GAAG,OAAOF,IAAI,KAAK,UAAU;EACvC,IAAIG,MAAM,GAAGC,MAAM,CAACC,OAAO,CAACJ,QAAQ,CAAC,CAACK,GAAG,CAAC,UAAUC,IAAI,EAAE;IACxD,IAAIC,KAAK;IAET,IAAIC,UAAU,GAAGF,IAAI,CAAC,CAAC,CAAC;MACpBG,QAAQ,GAAGH,IAAI,CAAC,CAAC,CAAC;IACtB,OAAOC,KAAK,GAAG;MACbE,QAAQ,EAAER,MAAM,GAAGQ,QAAQ,CAACV,IAAI,CAACA,IAAI,CAAC,KAAK,CAAC,CAAC,GAAGU;IAClD,CAAC,EAAEF,KAAK,CAACZ,eAAe,CAAC,GAAGa,UAAU,EAAED,KAAK,CAACb,SAAS,CAAC,GAAG,IAAI,EAAEa,KAAK;EACxE,CAAC,CAAC;EAEF,IAAIN,MAAM,EAAE;IACVC,MAAM,CAACH,IAAI,CAACA,IAAI,CAAC,IAAI,CAAC,CAAC;EACzB,CAAC,CAAC;EACF;EACA;;EAGA,OAAOR,WAAW,CAACW,MAAM,EAAE,UAAUQ,KAAK,EAAE;IAC1C,OAAOA,KAAK,CAACD,QAAQ;EACvB,CAAC,EAAEnB,gBAAgB,CAACqB,GAAG,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,YAAYA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,cAAc,EAAEC,aAAa,EAAE;EAC7E,IAAIhB,QAAQ,GAAGX,QAAQ,CAACwB,OAAO,EAAEC,QAAQ,CAAC;EAE1C,IAAIZ,MAAM,GAAGC,MAAM,CAACC,OAAO,CAACJ,QAAQ,CAAC,CAACK,GAAG,CAAC,UAAUY,KAAK,EAAE;IACzD,IAAInB,GAAG,GAAGmB,KAAK,CAAC,CAAC,CAAC;MACdJ,OAAO,GAAGI,KAAK,CAAC,CAAC,CAAC;IACtB,OAAO;MACLnB,GAAG,EAAEA,GAAG;MACRe,OAAO,EAAE,OAAOE,cAAc,KAAK,UAAU,GAAGF,OAAO,CAACd,IAAI,CAACgB,cAAc,CAAC,GAAGF;IACjF,CAAC;EACH,CAAC,CAAC;EACF,OAAO,OAAOG,aAAa,KAAK,UAAU,GAAGd,MAAM,CAACH,IAAI,CAACiB,aAAa,CAAC,GAAGd,MAAM;AAClF"},"metadata":{},"sourceType":"module","externalDependencies":[]}